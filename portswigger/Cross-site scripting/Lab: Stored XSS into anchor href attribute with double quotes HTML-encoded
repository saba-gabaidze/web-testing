Stored XSS — anchor href attribute (double-quotes HTML‑encoded)

Lab Difficulty: Apprentice
Vulnerability: Stored Cross‑Site Scripting (XSS) — injection into an anchor href attribute

Summary

Simple stored XSS in the comments. The app reflects whatever you put into the Website field into an anchor href for the comment author, but it HTML‑encodes the double quotes. That looked safe at first — until I noticed you can still inject a javascript: URL. So if you post javascript:alert(1) as the website, the author link becomes a JS URL that runs when opened. Easy win in the lab.

Steps Taken

Logged into the app and navigated to the post with the comment form.

In the Website field I first submitted a random alphanumeric string (e.g. abc123XYZ) so I could track where the value ends up. Intercepted the POST with Burp and forwarded it.

Opened the post page in the browser, intercepted the GET with Burp and sent that request to Repeater. In the response I found my random string reflected inside an anchor tag’s href attribute — the double quotes around attributes were HTML‑encoded, so nothing looked obviously broken, but my value was there. Nothing weird at first glance.

Went back to the comment POST in Burp Repeater and replaced the website value with the payload:

javascript:alert(1)


Resent the request. Loaded the post page and inspected the author link. The href now contained javascript:alert(1) (with double quotes HTML‑encoded around attributes, but the scheme itself executes).

Verified it by right‑clicking the author name → “Copy link address” → pasted the URL into the address bar — alert popped. Clicking the name in the page also triggered the alert. Lab solved.

Root Cause

The application stored and reflected user-controlled input into an anchor href without sanitizing or restricting the URI scheme. HTML encoding of attribute quotes alone does not stop dangerous schemes like javascript: from executing. The server trusted and reused the user-supplied website value directly in the link.

Fixes and Mitigation

Don’t allow dangerous URL schemes. Validate and normalize URLs server-side (allow only http, https, maybe mailto if needed).

If you accept URLs, parse them and reject or sanitize anything with javascript:, data:, or other executable schemes.

Canonicalize and validate inputs server-side — never rely solely on client-side checks.

As an extra layer, ensure output encoding is context‑aware (attribute encoding is good, but it must be combined with scheme checking).

Consider dropping direct link rendering for untrusted user input — show plain text or prepend https:// if you want to force safe navigation.
