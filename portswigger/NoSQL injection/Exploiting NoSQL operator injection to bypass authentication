Lab Difficulty: Apprentice
Vulnerability: NoSQL operator injection (MongoDB) allowing auth bypass

Summary
The login check uses MongoDB and trusts JSON-like input. You can inject MongoDB operators into the username and password fields. By using operators like $ne and $regex you can trick the query to match the admin account and log in as administrator. Nothing magical — just the app passing unvalidated input into a database query.

Steps taken

Opened the app in Burp’s browser and logged in with the provided user wiener:peter so I could see the normal login request.

In Proxy HTTP history I found the POST to the login endpoint and sent that request to Repeater.

In Repeater I started testing the username parameter. Replaced the username value with {"$ne":""} and sent the request. That caused the login to succeed because the username clause matched any non-empty name. Interesting.

Tried another operator: set username to {"$regex":"wien.*"} and the request also logged in, confirming regex operators work too.

Switched focus to the password parameter. With username still set to {"$ne":""}, changed password to {"$ne":""} and sent the request. The response indicated multiple records matched, so the query was now returning more than one user.

Finally, set password to {"$ne":""} and username to {"$regex":"admin.*"} and sent it. This successfully authenticated as admin.

To complete the lab, I viewed the successful response in the browser, copied the URL, opened it in Burp’s browser and confirmed I was logged in as administrator. Lab solved.

Root cause
The server builds MongoDB queries directly from user input without validating or sanitizing it. That makes it possible to inject operator objects that change the semantics of the query. Because the app doesn’t enforce strict types or whitelist fields, operators like $ne and $regex get executed by the database and let an attacker bypass authentication.

Fixes and mitigation
Validate and canonicalize input before using it in database queries. Don’t accept raw JSON objects for username or password fields.
Treat user-supplied values as plain strings, not query fragments. If you must accept JSON, strictly parse and reject any objects containing operator keys that start with $.
Use parameterized query builders or driver APIs that separate data from operators.
Add server-side rate limiting and monitoring for unusual login queries and failures.
Ensure authentication logic expects exact types and values and never directly injects user input into query structures.
