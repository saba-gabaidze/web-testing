Lab: Exploiting NoSQL operator injection to extract unknown fields

Lab Difficulty: Practitioner
Vulnerability: NoSQL injection in MongoDB, including evaluated JavaScript via $where

Summary
This lab shows a classic MongoDB injection where the app accepts NoSQL operators and even evaluates JavaScript in a $where clause. By abusing that we can enumerate object keys on a user record, discover the name of the password reset token field, and then extract Carlos’s reset token value. With the token we open the reset flow, change the password, and log in as Carlos. Pretty neat and messy at the same time.

Steps taken

Tried to log in as carlos with a wrong password to get a baseline error: Invalid username or password.

Sent the POST /login request to Repeater and replaced the password value invalid with the JSON operator {"$ne":"invalid"}. The response changed to Account locked, which told me the server accepts NoSQL operators. Nothing weird at first glance, but this confirmed injection.

Tried the password reset flow in the browser and saw it uses email verification, so that route was blocked. I switched back to testing injection.

In Repeater I added a $where parameter to the JSON body to test JS evaluation. With "$where": "0" I got Invalid username or password. With "$where": "1" I got Account locked. That proved the $where code is executed.

Sent the request to Intruder and used a cluster bomb attack to enumerate object keys on the user document. The $where payload was something like Object.keys(this)[1].match('^.{}.*') and then refined to Object.keys(this)[1].match('^.{§§}§§.*') with two payload positions. Payload 1 was numeric positions, payload 2 was a list of characters (0-9, a-z, A-Z).

Ran the attack and sorted results to find responses showing Account locked. Reading the matched characters spelled out a field name: username.

Repeated the same technique incrementing the index into Object.keys(this) to discover further fields. One of the fields turned out to be the password reset token name.

Confirmed the reset token field name by calling the GET /forgot-password endpoint with a bogus query param. GET /forgot-password?foo=invalid returned the normal page, while GET /forgot-password?THE_TOKEN_NAME=invalid returned Invalid token. That validated the correct field name and endpoint.

Went back to Intruder and adjusted the $where payload to leak the value of Carlos’s reset token, e.g. "$where":"this.THE_TOKEN_NAME.match('^.{§§}§§.*')" and used the same cluster bomb approach (position for index and position for character).

Extracted the token value from the Intruder results by collecting the characters that produced Account locked responses.

Used the token by pasting it into the GET /forgot-password?THE_TOKEN_NAME=TOKENVALUE URL and opened that request in Burp’s browser (Request in browser, original session). The reset page loaded, I changed Carlos’s password, then logged in as Carlos. Lab solved.

Root cause
The app accepts MongoDB query operators directly from user-supplied JSON and even executes JavaScript provided in $where. There’s no server-side validation or field-level access control, so you can both enumerate document keys and read arbitrary field values if you can craft the right $where expression.

Fixes and mitigation

Never accept raw NoSQL operators from untrusted input. Parse and validate input server-side and reject JSON that contains operators like $ne, $where, etc.

Disable JavaScript evaluation in queries. Don’t use $where with user-controlled content.

Implement strict input validation and schema enforcement for query parameters. Use parameterized queries or ORMs that prevent operator injection.

Enforce least privilege on database queries and avoid exposing internal field names in predictable order.

Add monitoring and alerting for unusual query shapes, such as requests containing $where or other operators in login endpoints.
