Lab: Exploiting DOM clobbering to enable XSS

Difficulty: Expert
Vulnerability: DOM clobbering → DOM-based XSS

Summary

Short version: the app tries to be “safe” by sanitizing comments, but a DOM-clobbering trick plus a permissive cid: URL lets us overwrite a global object used by the page. When the page later trusts that object and injects it into the DOM, the onerror handler we smuggled runs and alert(1) pops. Works in Chrome because of how ID/name collections and cid: decoding behave there.

Nothing fancy — just abusing how the page builds a fallback with || and how anchors with the same id/name form collections.

Steps taken (what I actually did)

Logged in / opened a blog post page and inspected the comments loading script. Found it imports loadCommentsWithDomClobbering.js and saw this line:

let defaultAvatar = window.defaultAvatar || { avatar: '/resources/images/avatarDefault.svg' }


That || pattern raised a red flag — it lets a global window.defaultAvatar override the safe fallback.

I added a comment containing the following HTML (exact payload):

<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">


(That's two anchors with the same id. The second anchor has name="avatar" and an href crafted to contain an encoded " which decodes into onerror=alert(1)//.)

I then posted a second comment with any text (just to trigger the normal comment rendering on next load).

Reload the blog post. The script runs again, and because the global defaultAvatar has been clobbered by the anchor collection, the page uses { avatar: 'cid:"onerror=alert(1)//' }. That value later ends up in an <img> or similar, the cid:"onerror=alert(1)//' injects onerror=alert(1) into an attribute and the browser executes it — alert(1) fires.

Verified payload only triggers in Chrome (the lab notes that the intended solution is Chrome-specific).

Why this works (root cause)

The code uses a dangerous fallback pattern: window.defaultAvatar || { ... }. That trusts any truthy window.defaultAvatar — even if it’s attacker-controlled DOM content.

DOM clobbering: elements with the same id can form collections that overwrite properties on window/global scope in some browsers. Creating anchors with id=defaultAvatar and name=avatar causes window.defaultAvatar.avatar to be set to the anchor’s href (or similar behavior) in Chrome.

DOMPurify was present but insufficient: DOMPurify allowed cid: URIs and did not URL-encode double quotes in that scheme, so an encoded &quot; becomes a real " at runtime — letting us break out into an attribute like onerror.

The chain: attacker controls DOM → clobbers global object → script trusts global → unsafe data ends up in HTML attribute → browser executes event handler.

Fixes & Mitigation (how to stop this)

Short, practical list:

Stop using || with globals for security-sensitive defaults.
Replace let defaultAvatar = window.defaultAvatar || ... with explicit checks and safer assignments. Example:

let defaultAvatar;
if (typeof window.defaultAvatar === 'object' && window.defaultAvatar !== null) {
  // additional validation on properties
  defaultAvatar = validateAvatarObject(window.defaultAvatar) ? window.defaultAvatar : { avatar: '/resources/...' };
} else {
  defaultAvatar = { avatar: '/resources/...' };
}


Validate types and expected formats before using.

Don’t rely on globals populated by DOM elements.
Avoid using global variables whose values can be influenced by element id/name collisions. Access DOM elements explicitly (e.g., document.getElementById(...)) and validate what you get.

Harden DOMPurify / sanitizer config.

Disallow risky protocols like cid: in attributes. Configure the sanitizer to only allow http, https, mailto, and data: where appropriate, or use a strict protocol whitelist.

Ensure attribute values are encoded/escaped and quotes are not decoded unexpectedly.

Avoid relying on browser quirks (id/name clobbering).
Treat element id/name collisions as dangerous. Don’t allow user content to supply IDs that could conflict with JS variable names or expected DOM structure.

Contextual encoding on output.
When inserting values into HTML attributes, use proper attribute encoding (not raw insertion). If building an img element, set img.src via DOM API, not via innerHTML building with untrusted strings.

CSP (Content Security Policy).
Add an appropriate CSP that disallows unsafe-inline scripts and event-handler attributes where possible. This won’t fix the root problem but raises the cost for exploitation.

Audit libraries & patterns for other ||-style fallbacks and replace them with robust checks.
