Lab: Exploiting DOM clobbering to enable XSS

Difficulty: Expert
Vulnerability: DOM clobbering → DOM-based XSS (Chrome-only quirk)

Summary 

This lab abuses DOM clobbering to overwrite a defaultAvatar object that the page trusts. The app builds an <img src="..."> using defaultAvatar.avatar (or a comment-supplied avatar), but the code uses a dangerous pattern (window.defaultAvatar || { ... }) plus innerHTML string-building. By injecting two anchors that share the same id and using the second anchor’s name="avatar" + a cid: URL that contains an unencoded " (decoded at runtime), the attacker can clobber the avatar property so it ends up as something like cid:"onerror=alert(1)// and that gets smuggled into an img tag’s src. When the image loads, the injected onerror fires and alert(1) runs. Chrome’s handling of the cid: protocol + DOM clobbering makes this work.

Nothing crazy at first glance — just some creative HTML trickery and a bad server/client pattern.

Steps taken 

Opened a blog post and inspected how comments are displayed. Noticed the page fetches comments via XHR and then builds comment HTML using a string (via innerHTML) rather than creating DOM nodes safely.

Saw the important line in loadCommentsWithDomClobbering.js (or similar):

let defaultAvatar = window.defaultAvatar || { avatar: '/resources/images/avatarDefault.svg' }


That || pattern means: if an attacker creates a global defaultAvatar, the script will use it. That’s the DOM-clobbering sweet spot.

Looked at how the avatar is inserted:

let avatarImgHTML = '<img class="avatar" src="' + (comment.avatar ? escapeHTML(comment.avatar) : defaultAvatar.avatar) + '">';
divImgContainer.innerHTML = avatarImgHTML;


So whatever defaultAvatar.avatar evaluates to gets concatenated into an img src inside a string, then injected with innerHTML. That’s a parsing surface where an attacker can smuggle attributes if they can control the string content.

Realized we can clobber window.defaultAvatar using DOM clobbering: create two elements with id="defaultAvatar". The browser groups same-id anchors into a collection accessible from window.defaultAvatar. If the second anchor has name="avatar" and an href, then window.defaultAvatar.avatar becomes that href value.

DOMPurify is used by the app, but it allows cid: URIs and does not URL-encode " inside cid:. That means we can inject an encoded &quot; that will decode to " at runtime (Chrome behavior), letting us break out of the src="..." context and add an onerror handler.

The working payload (post this as the first comment):

<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">


Then post a second (harmless) comment (or reload after making a second comment). On the next page load, window.defaultAvatar is clobbered and defaultAvatar.avatar evaluates to the specially crafted cid:"onerror=alert(1)//. That gets injected into the img src, the " breaks out, onerror=alert(1) attaches to the <img>, and the alert fires. Chrome executes it — lab solved.

Why this works (root cause, succinct)

Unsafe fallback pattern: window.defaultAvatar || {...} trusts any global window.defaultAvatar without verifying its type or content. That allows attacker-controlled DOM clobbering to influence app data.

DOM clobbering via same-id elements: Multiple elements with the same id can be exposed as a named collection, making window.defaultAvatar.avatar possible.

String-based HTML insertion (innerHTML): Building HTML via string concatenation and inserting via innerHTML creates a parsing surface where attribute-breaking payloads can be smuggled.

DOMPurify + cid: quirk: DOMPurify in this app allows cid: URIs and those can contain a &quot; which decodes into an actual double-quote at runtime in Chrome — that lets the attacker break out of the attribute value.

Browser-specific parsing: The attack relies on Chrome’s handling of cid: quotes and DOM clobbering behavior — so it’s Chrome-only.
