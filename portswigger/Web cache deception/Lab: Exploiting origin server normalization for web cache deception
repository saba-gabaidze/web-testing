Lab: Exploiting origin server normalization for web cache deception

Difficulty: Practitioner

This one was about web cache deception, but with a twist — the origin server was doing normalization on dot-segments (..), and we had to use that against a static cache rule to trick the cache into storing sensitive data. The goal was to leak Carlos’s API key.

Plan
The general idea was to:

Find a way to access /my-account with a modified path that still gives a valid response

Confirm if the origin server and cache treat that path differently

Use the static /resources cache rule to trick the cache into storing the response

Get Carlos to hit the malicious URL so the cache stores his API key

Grab it from the cache ourselves

Step-by-step
1. Logged in with wiener:peter and looked at /my-account

The API key was right there in the response. So this is our target.

2. Tested path delimiters like /my-account?abc

Used Intruder to try a bunch of delimiters. All gave 404 except for ?, which still gave a 200 and the API key. So ? is our effective delimiter, but not useful for cache deception by itself.

3. Tried origin path normalization with dot-segments

In Repeater, tested this:


/aaa/..%2fmy-account
And it gave a 200 with the API key — nice. So the origin server is decoding that %2f into a /, resolving the path to /my-account.

4. Now looked for a static cache rule

I checked requests for static files (like CSS/JS), and all of them started with /resources/. Noticed they had X-Cache: miss on the first request, and X-Cache: hit on the second. So anything under /resources gets cached.

Then I tested this:

/resources/aaa
Same result — miss on first, hit on second. Confirmed: there’s a static directory-based cache rule on /resources.

5. Combined it all together

Tried this:

/resources/..%2fmy-account
Boom — got a 200 response with the API key and X-Cache: miss. Sent it again, got X-Cache: hit. That means the cache is storing the response, but because of the normalization, the origin server sees it as /my-account.

Perfect.

6. Delivered the exploit to Carlos

Went to the exploit server and sent this payload:


<script>
document.location="https://YOUR-LAB-ID.web-security-academy.net/resources/..%2fmy-account?wcd"
</script>
That ?wcd at the end is just a cache buster to avoid showing my cached version.

Clicked “Deliver exploit to victim”.

7. Visited the cached URL

After Carlos hit it, I loaded the same URL. The response was cached — and now it had his API key in it.

Copied that key, submitted it, done.

Root Cause
Origin server resolves encoded dot-segments and treats /resources/..%2fmy-account as /my-account

Cache doesn’t normalize — just sees /resources/..%2fmy-account and stores it

That mismatch creates the perfect web cache deception scenario

Fixes
Cache rules shouldn’t blindly trust path prefixes like /resources/

Normalize URLs consistently across both cache and origin

Sanitize and restrict dot-segment usage in paths if not required
