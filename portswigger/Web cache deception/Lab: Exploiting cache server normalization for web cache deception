Lab: Exploiting cache server normalization for web cache deception

Difficulty: Practitioner

This one was all about messing with how the cache server and the origin server interpret and normalize URLs differently. The idea is to trick the cache into storing a sensitive response (like the /my-account page with the API key), then serve it up publicly through a disguised URL.

Here’s how it went down.

Step 1: Check the target
Logged in as wiener:peter and went to /my-account. The page showed my API key. Cool, that’s what we’re after — just need Carlos’s now.

Tried adding junk to the URL like /my-account/abc and /my-accountabc. Both gave 404s, so the origin server isn’t being forgiving with the path.

Step 2: Brute-force delimiters
I sent /my-account to Intruder and added different characters like ?, %3f, %23, etc. right after it. Wanted to see which ones the origin server treated as valid path delimiters but still gave me a 200 with my API key.

Got 200 responses for:

?

%3f

%23

Ignore # because it’s client-side only — the browser never sends it to the server.

Step 3: Check if cache behaves the same way
Now I needed to see how the cache saw things. If it treats a delimiter differently than the origin, that’s where the gap (and exploit) lies.

I tried /my-account?abc.js, /my-account%3fabc.js, and /my-account%23abc.js. None of these showed evidence of caching — meaning no X-Cache: hit.

But then I looked at how static files (like images or JS) were handled. Noticed they were all under /resources, and requests to those paths did show X-Cache: hit on second request. That’s a sign the cache stores stuff under /resources.

Step 4: Test normalization behavior
I tried adding encoded dot segments to the path like:

/aaa/..%2fresources/YOUR-RESOURCE
First request was X-Cache: miss, second one was X-Cache: hit. So the cache server normalized that dot-segment and treated it like /resources/YOUR-RESOURCE.

I also tried:

/resources/..%2fYOUR-RESOURCE
And that broke the caching — good sign. It means the cache treats /resources specially and doesn’t cache if the structure is messed with.

Step 5: Build the exploit
I went back to /my-account and crafted a URL that uses the %23 delimiter (so cache sees it as a static resource) and also includes an encoded traversal to /resources.

Tried this in Repeater:

/my-account%23%2f%2e%2e%2fresources
Got a 200 and X-Cache: miss on first request. Resent — now it was X-Cache: hit. That means it’s cached.

Now I just needed Carlos to visit this path.

Step 6: Deliver the payload
On the exploit server, I used:

<script>document.location="https://YOUR-LAB-ID.web-security-academy.net/my-account%23%2f%2e%2e%2fresources?wcd"</script>
Hit “Deliver exploit to victim”.

Then visited that same URL myself and boom — got back Carlos’s API key from the cached /my-account page.

Submitted the key and lab solved.

Root cause
The cache server normalized the path differently than the origin

Delimiters like %23 confused the cache into thinking it was dealing with a static resource

Dot-segments (..%2f) let us jump paths and abuse caching rules

Fixes
Cache rules need to match origin server routing logic exactly

Normalize paths consistently on both ends

Treat user-controlled URLs with caution when caching is involved
