Lab: Exploiting exact-match cache rules for web cache deception

Difficulty: Expert

This one was all about cache behavior and tricking the app into leaking the admin’s CSRF token. The goal was to change the admin’s email address, and the path there involved a mix of weird path tricks, URL delimiters, and some CSRF.

Step 1: Check out /my-account
Logged in with wiener:peter and went to the “My account” page. The form to change email had a hidden CSRF token. Pretty standard stuff.

I sent that request to Repeater and tried messing with the path:

/my-account/abc gave a 404.

/my-accountabc also gave a 404.

Tried a few delimiters like ; and ? — turns out both split the path at that point.

Then I checked if the app normalized paths. Tried something like /aaa/..%2fmy-account — got a 404, so the app doesn’t normalize those dot-segments. But the cache does.

Step 2: Look for something that actually gets cached
Checked /robots.txt and saw X-Cache: miss on the first request and X-Cache: hit on the second. Jackpot — this file is definitely cached.

Then I tried /aaa/..%2frobots.txt — still got a cached response. So the cache does normalize the path. Good to know.

Step 3: Trick the cache into saving /my-account
The idea now was to disguise /my-account as something that would get cached. So I did this:


/my-account;%2f%2e%2e%2frobots.txt
That semicolon acts as a delimiter — the app sees it as /my-account, but the cache sees /robots.txt.

Sent that request and saw X-Cache: miss. Sent it again — X-Cache: hit. Perfect.

Step 4: Steal the admin’s CSRF token
On the exploit server, I made a little payload:

<script>
document.location = "https://YOUR-LAB-ID.web-security-academy.net/my-account;%2f%2e%2e%2frobots.txt?wcd"
</script>
Delivered it to the victim.

Then quickly (within 30 seconds) sent the same URL in Burp Repeater. Response came back with the CSRF token — and it belonged to the admin.

Step 5: Use the token to change the admin’s email
Took the admin’s CSRF token, opened the POST /my-account/change-email request, swapped in the token, changed the email to something else, and sent it.

Done — lab solved.

Root Cause
The cache used normalized paths, the app didn’t — big mismatch.

The app trusted data from a non-cache-safe URL.

Exact-match file caching rules made it easy to trick the cache into storing sensitive info.

The admin’s CSRF token got cached and exposed to other users.

Fixes
Don’t cache responses that include user-specific data.

Make sure the app and cache normalize and interpret paths the same way.

Avoid using exact-match cache rules for sensitive paths.

Treat delimiter characters carefully — don’t let them cause confusion between the cache and the app.
