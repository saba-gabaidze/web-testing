Lab: SQL injection in WHERE clause — retrieve hidden products

Difficulty: Apprentice
Vulnerability: SQL Injection (filter parameter)

Summary

Simple one — the product category filter is fed straight into a SQL WHERE clause with no protection. By tampering with the category parameter you can turn the WHERE into a tautology and bypass the released = 1 check, which reveals unreleased products. Nothing fancy, just classic SQLi in a filter.

Steps taken (what I did)

Opened the app and navigated to the product listing where you can choose a category (e.g. Gifts).

Watched the request with Burp Suite while switching categories. The backend runs a query like this:

SELECT * FROM products WHERE category = 'Gifts' AND released = 1


Nothing weird visible in the UI, but that released = 1 caught my eye — means unreleased products are explicitly filtered server-side. Interesting.

Intercepted the category-change request in Burp. The parameter looked like category=Gifts in the request.

Sent the request to Repeater and replaced the category value with a SQL injection payload. I used both a readable and URL-encoded form:

Readable:
category=' OR 1=1--

URL-encoded (what you’d actually send in a GET/POST):
category=%27+OR+1%3D1--

The idea: close the category string, OR a true condition (1=1), then comment out the rest so AND released = 1 is ignored.

Sent the modified request. Response now included additional products — some marked unreleased (or previously hidden). Bingo — lab solved.

Example of how the server-side WHERE becomes exploitable (conceptual):

Original: SELECT * FROM products WHERE category = 'Gifts' AND released = 1

After injection (rough idea): SELECT * FROM products WHERE category = '' OR 1=1--' AND released = 1
=> effectively: WHERE (TRUE)


Because -- comments out the rest, the released = 1 check is skipped and all rows return.

Root Cause

User input (the category filter) is concatenated into a SQL statement with no parameterization or proper escaping. The server trusts client-controlled data and the DB executes whatever logic that data injects. Classic SQL injection.

Fixes & Mitigation

Use parameterized queries / prepared statements — never concatenate user input into SQL.

Validate input server-side — only accept known-good category values (whitelist).

Least privilege DB user — the DB account should have only the minimal permissions needed.

Escape and sanitize where parameterization isn’t possible (but prefer parameterization).

Avoid showing raw DB errors to the user.

Implement an allowlist for filter values — e.g., check that category matches one of the expected categories before querying.
