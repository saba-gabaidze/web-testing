Accessing HTTP request smuggling  basic CL.TE 

Lab difficulty: Practitioner
Vulnerability: HTTP request smuggling  front-end and back-end parsing mismatch

Summary
This lab has a front-end proxy that doesn’t support chunked encoding and only accepts GET or POST. The back-end accepts chunked encoding. By sending a carefully crafted request that the front-end treats one way and the back-end treats another, you can smuggle a small extra request to the back-end so the next request the back-end processes looks like it used the method GPOST. The lab expects you to trigger the back-end to respond with “Unrecognized method GPOST.”

Steps taken

Opened Burp Repeater and made sure the request protocol is set to HTTP/1.1 (the lab supports HTTP/2 but the exploit requires HTTP/1).

Built the request and sent it twice. The trick is to include both Content-Length and Transfer-Encoding headers so the front-end and back-end parse the body differently. Here’s the request used:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Connection: keep-alive
Content-Type: application/x-www-form-urlencoded
Content-Length: 6
Transfer-Encoding: chunked

0

G


Notes about that payload: the chunked section is just the terminating chunk 0 followed by a blank line, then the extra G byte. The front-end, which doesn’t support chunked, will honor Content-Length=6 and think the request body ends after reading 6 bytes (but since the actual chunking is weird, it lets the G byte through to the back-end). The back-end, which does support chunked, sees the 0 (end of chunks) and then interprets the trailing G as the start of a smuggled request, resulting in the next request being seen as starting with GPOST ... which the back-end flags as an unrecognized method.

Sent this request twice. The second response returned the expected message: Unrecognized method GPOST. Lab solved.

Root cause
Front-end and back-end servers parse request framing differently. The front-end rejects chunked encoding but still accepts the headers, while the back-end accepts chunked. When both Content-Length and Transfer-Encoding are present, the two servers interpret the body differently, allowing extra bytes to be interpreted as a new request by the back-end. That difference in how each server handles message length is the core of CL.TE request smuggling.

Fixes and mitigation

Make sure front-end and back-end agree on HTTP parsing rules. Disable inconsistent features on proxies or align their behavior.

Remove support for conflicting headers: do not allow both Content-Length and Transfer-Encoding together; normalize requests at the proxy edge.

Drop or properly handle Transfer-Encoding headers at the proxy (strip them or reject requests that use unsupported encodings).

Add strict request validation and logging at both layers to detect anomalous request framing.

Keep HTTP protocol handling libraries up to date and follow vendor guidance for reverse-proxy behavior.
