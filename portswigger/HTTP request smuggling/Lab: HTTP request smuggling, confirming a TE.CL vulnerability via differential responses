HTTP request smuggling TE.CL confirmed via differential responses

Lab Difficulty: Practitioner
Vulnerability: HTTP request smuggling, TE.CL variant

Summary
This lab has a front-end proxy and a back-end server that does not support chunked encoding. By smuggling a crafted request using conflicting Transfer-Encoding and Content-Length headers, you can get the back-end to treat part of your payload as a new request. That makes the next request the client sends get processed oddly by the back-end and return a 404 for the root path. Classic TE.CL behavior — weird, but effective.

Steps taken

Opened Burp Repeater and made sure the automatic Content-Length fix was turned off. Manual control is required here, so disabling Update Content-Length is important.

Switched the request protocol to HTTP/1.1 in Repeater if needed (the lab supports HTTP/2 but the exploit needs HTTP/1.1).

Sent the following crafted request twice (replace Host with the lab host):

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

5e
POST /404 HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


Nothing fancy in the first glance. What this does is trick the front-end proxy to forward a chunked body to the back-end while the back-end doesn’t support chunked encoding. The back-end ends up parsing the injected second request line POST /404 HTTP/1.1 as a new request.
4. After sending that smuggling request twice, I sent a normal GET for the web root. The response from the server for the root request returned 404 Not Found. That indicates the back-end consumed the subsequent client request as part of the smuggled request, confirming a TE.CL vulnerability. Lab solved.

Root cause
The front-end accepts chunked Transfer-Encoding and forwards a payload the back-end can’t correctly parse. The mismatch in how the two servers handle Transfer-Encoding and Content-Length leads to a desync. The back-end ends up seeing different request boundaries than the front-end, allowing an attacker to smuggle a request that alters how subsequent requests are processed.

Fixes and mitigation
• Make sure front-end and back-end agree on which transfer encodings are supported. If the back-end does not support chunked encoding, the front-end must strip or reject Transfer-Encoding headers.
• Normalize and validate request framing at the proxy layer so a single canonical interpretation exists.
• Reject requests with conflicting headers, such as both Transfer-Encoding and Content-Length present in ways that could conflict.
• Implement strict request size and header limits and log anomalous framing or unexpected request remainders.
• Consider using modern, well-tested proxies that automatically normalize these edge cases and keep consistent behavior between tiers.
