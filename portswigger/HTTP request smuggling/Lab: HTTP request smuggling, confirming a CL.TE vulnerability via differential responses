Accessing the back-end via request smuggling 
Lab Difficulty: Practitioner
Vulnerability: HTTP request smuggling CL.TE confirmed by differential responses

Summary
The front-end server doesnâ€™t support chunked encoding but the back-end does. That mismatch lets you smuggle a request to the back-end by sending a message that the front-end treats as finished while the back-end continues reading. After the smuggle, a follow-up request for the site root returns a 404, which proves the back-end processed the injected request (we smuggled a GET /404 to the back-end).

Steps taken

Opened Burp Repeater and made sure the request was using HTTP/1.1 (the lab supports HTTP/2 but the technique needs HTTP/1.1).

Built a POST that contains both a Content-Length header and a Transfer-Encoding: chunked header. The trick is to make the front-end respect Content-Length while the back-end obeys Transfer-Encoding.

Sent the POST twice. The request used in the lab looked like this:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 35
Transfer-Encoding: chunked

0

GET /404 HTTP/1.1
X-Ignore: X


The first time primes the back-end. The second time the response for the follow-up GET changed and returned 404, proving the back-end executed the smuggled GET /404. That differential response confirms a CL.TE smuggling vulnerability and completes the lab.

Why it works (root cause)
The front-end and back-end disagree on how to parse the message body. The front-end trusts Content-Length and believes the request body ends, so it forwards the remaining bytes (the injected GET) to the back-end as a separate request. The back-end honors Transfer-Encoding: chunked and treats the same bytes as continuing the original connection, so it ends up executing the injected request. That parsing mismatch is the core of CL.TE request smuggling.

Fixes and mitigation

Make sure all proxies and upstream servers parse requests the same way. Consistent HTTP parsing eliminates the mismatch that enables smuggling.

Reject requests that include both Content-Length and Transfer-Encoding headers. Treat that combination as invalid.

Normalize request bodies at the front-end: remove Transfer-Encoding or Content-Length ambiguity before forwarding.

Log and monitor suspicious header combos and unexpected 1xx/3xx/4xx patterns that might indicate smuggling attempts.

Apply strict input validation on any upstream HTTP request data that affects routing or resource access.
