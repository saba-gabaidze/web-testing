HTTP request smuggling 

Lab Difficulty: Practitioner
Vulnerability: HTTP request smuggling  Transfer-Encoding / Content-Length mismatch

Summary
Front-end and back-end servers are not aligned on how they parse request bodies. The back-end doesn’t support chunked encoding, so if you send a request that tricks the front-end into forwarding a crafted payload, the back-end will see a smuggled request starting with the method GPOST. In short: teach the front-end to chop the stream wrong, and the back-end ends up processing a fake GPOST request. Interesting and classic.

Steps taken

Opened the lab in Burp and confirmed the app uses both a front-end and a back-end proxy. The front-end rejects non-GET/POST methods, and the back-end doesn’t support chunked encoding.

In Burp Repeater, turned off the automatic Content-Length update so Burp wouldn’t correct our intentional mistakes.

Switched Repeater to HTTP/1.1 (the lab supports HTTP/2 but the intended technique needs HTTP/1.1). You can change this in the Request attributes section of the Inspector.

Sent the same crafted request twice from Repeater. The payload is designed so the front-end sees a chunked body and forwards bytes that the back-end parses as a separate request with method GPOST. Here’s the exact request used:

POST / HTTP/1.1
Host: YOUR-LAB-ID.web-security-academy.net
Content-Type: application/x-www-form-urlencoded
Content-length: 4
Transfer-Encoding: chunked

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


Make sure to include the trailing sequence CRLF CRLF after the final 0.
5. The first request primes the back-end stream. The second request triggers the back-end to process the leftover bytes as a new request. The back-end responds with Unrecognized method GPOST. That response confirms the smuggle worked.

Result
The second response returned Unrecognized method GPOST, proving the back-end parsed the injected GPOST line as a request. Lab solved.

Root cause
The front-end and back-end disagree on how to interpret request boundaries. The front-end accepts Transfer-Encoding: chunked and forwards data; the back-end does not understand chunked encoding and treats extra bytes as a new request. Because the app didn’t validate or normalize how requests are framed, an attacker can smuggle a request to the back-end.

Fixes and mitigation
• Ensure consistent parsing rules across proxies and backend services. All intermediaries must handle Transfer-Encoding and Content-Length the same way.
• Strip or normalize Transfer-Encoding headers at the edge. If back-end doesn’t support chunked, the edge should reject chunked requests or convert them safely.
• Validate HTTP methods strictly and block suspicious request framing at the front-end.
• Add request length checks and tight timeouts so leftover bytes can’t be misinterpreted as a new request.
• Use up-to-date web servers and proxies with known smuggling mitigations and keep them patched.
