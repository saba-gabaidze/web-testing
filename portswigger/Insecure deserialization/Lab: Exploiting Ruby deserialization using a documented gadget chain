Client-side Marshal cookie — Ruby deserialization gadget (Apprentice)

Lab Difficulty: Apprentice
Vulnerability: Insecure deserialization — client-side session stored as a marshaled Ruby object (Marshal.load on untrusted data) allowing gadget-chain command execution

Summary

The app keeps the session in a cookie as a marshaled Ruby object. The server Marshal.loads that cookie back into objects — and that’s the problem. If you can replace the cookie with a crafted marshaled object that uses a known Ruby gadget chain, the server will instantiate objects that end up calling dangerous code.
In this lab the goal was to build a marshaled payload (using a documented vakzz gadget chain), change the command to rm /home/carlos/morale.txt, Base64 it, stick it into the session cookie (URL-encoded), and send it. If the server loads it, the command runs and the lab is solved.

Steps Taken

Logged in with the provided account (wiener : peter) and captured a request that contained the session cookie.

Copied the cookie into Burp Repeater and decoded it (URL-decode / Base64 decode as needed). The token decoded to a marshaled blob — you can usually spot Marshal data (binary-ish, often starting with \x04\bo: or similar). That confirmed the cookie transport was Base64/URL-encoded marshaled bytes. Nothing weird at first glance, but now I knew the exact encoding the app expected.

Followed the lab hint to use the documented “Universal Deserialisation Gadget for Ruby 2.x–3.x (vakzz)”. I grabbed the gadget-building script and adapted it locally: changed whatever demo command it used to rm /home/carlos/morale.txt, and modified the script to print the final payload as Base64 (so it matches the cookie transport). Important: gadget chains are version-sensitive, so I kept the chain the lab recommended.

Ran the wrapper script locally (on a compatible Ruby version) to get the Base64 marshaled payload. Copied that Base64 output.

In Burp Repeater, replaced the session token in a captured cookie with the Base64 payload, URL-encoded the full cookie value, and sent the request to the app.

If the gadget chain works and the server Marshal.loads the cookie, the rm /home/carlos/morale.txt command executes and the lab marks as solved.

Root Cause

The server blindly deserializes user-controlled bytes (Marshal.load on data taken from a client cookie). Ruby’s Marshal can instantiate real objects and trigger behavior during object construction or via methods like marshal_load, to_s, inspect, etc. Existing standard-library or framework classes can be chained (gadgets) so that deserialization leads to command execution. The app trusted the client-side session and didn’t validate or authenticate the serialized contents.

Fixes and Mitigation

Stop trusting client-side serialized objects. Don’t store Marshal.dump’d session objects in a cookie that the server will Marshal.load later.

Use server-side sessions (or signed/encrypted tokens where the server only accepts its own signature and never loads arbitrary objects).

If any serialization is necessary, use safe formats (JSON) and never serialize objects with executable behavior.

Strictly validate and authenticate session data. If you must transport state client-side, sign and/or encrypt it and reject anything that can’t be verified.

Avoid using Marshal.load on untrusted input. If you must deserialize, use safe libraries or limit deserialization to whitelisted classes only.

Keep dependencies/versions updated and monitor for known gadget-chain issues in libraries you include.
