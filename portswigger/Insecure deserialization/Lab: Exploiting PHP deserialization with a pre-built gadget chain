Privilege via PHP object deserialization (signed cookie) Symfony gadget chain  RCE

Lab Difficulty: Apprentice
Vulnerability: Insecure deserialization of a signed, Base64‑encoded PHP object in a session cookie (gadget chain  RCE)

Summary

The app keeps session/state in a cookie that contains a Base64‑encoded serialized PHP object plus an HMAC signature. The server will only accept cookies whose signature matches  so you can’t just swap the object bytes unless you can also sign them. The lab leaks the server secret via phpinfo(), so you can build a serialized gadget (using PHPGGC), Base64 it, HMAC‑sign it with the leaked secret, put it into the cookie, and boom — when the server unserializes it it runs your command.

In short: produce a gadget payload → sign it with leaked secret → send cookie → server unserializes and executes your command.

High‑level goal & vulnerability model

The cookie looks like {"token":"<BASE64_SERIALIZED_OBJECT>","sig_hmac_sha1":"<HMAC_SHA1_SIGNATURE>"} (URL‑encoded in transit).

Server flow: verify sig_hmac_sha1 by computing hash_hmac('sha1', $token, $secret) and comparing → if OK, unserialize(base64_decode($token)) happens somewhere.

If you can craft a serialized object that triggers code execution when unserialized (gadget chain), and you can produce a matching HMAC using the server secret, you get RCE.

Nothing weird at first glance — but signed tokens + unserialize = jackpot if secret leaks.

Steps I took (repro)

Logged in as wiener : peter and captured a request with the session cookie. Copied the cookie value into Burp so I could inspect it.

URL‑decoded the cookie → got JSON. Pulled the token field and Base64‑decoded it → got a PHP serialized blob (starts with O: and class names). Confirmed the sig_hmac_sha1 value is present.

Quick test: modify the token bytes and resend without changing signature → server rejects (signature mismatch). So signature is enforced.

Looked for leaks. Found /cgi-bin/phpinfo.php (developer left it) and opened it. Found APP_SECRET / SECRET_KEY used by Symfony — that’s the HMAC key. Nice leak.

Identified the framework/version from other hints (error message / developer comment) — Symfony 4.3.6 — which tells me which gadget chains will work.

Used PHPGGC to build a gadget chain for Symfony (the lab hints at Symfony/RCE4). Example command I ran locally:

./phpggc Symfony/RCE4 exec 'rm /home/carlos/morale.txt' | base64


That prints a Base64‑encoded serialized object that, when unserialized by that Symfony version, executes rm /home/carlos/morale.txt. (You can swap exec for any command you need, e.g., spawn a reverse shell if the lab allows outbound connections.)

Took the Base64 string produced by phpggc and used this PHP snippet (locally) to compute the signed cookie value — replacing the two placeholders:

<?php
$object = "OBJECT-GENERATED-BY-PHPGGC";           // replace with phpggc's Base64 output
$secretKey = "LEAKED-SECRET-KEY-FROM-PHPINFO.PHP"; // replace with value from phpinfo

$cookie = urlencode('{"token":"' . $object . '","sig_hmac_sha1":"' . hash_hmac('sha1', $object, $secretKey) . '"}');
echo $cookie;


hash_hmac('sha1', $object, $secretKey) computes the signature the server expects.

urlencode(...) makes it safe to paste into the cookie header.

Pasted the printed value into the session cookie in my Burp request and forwarded it to the server. If everything is right (object bytes + signature + correct gadget chain matching framework version), the server accepts it and unserializes the object — and the gadget chain triggers the command.

Verified success: the target file /home/carlos/morale.txt was removed (lab objective) — lab solved.

Why this works (root cause)

The server trusts a serialized object stored in a cookie and unserializes it. Unserialization in PHP can trigger magic methods (__wakeup, __destruct, etc.) which gadgets abuse to call dangerous functions.

Signature prevents blind tampering, but the secret was leaked via phpinfo() — once you have the HMAC key, you can create any signed token you want.

So it’s a two‑part failure: (1) dangerous use of unserialize() on untrusted input, and (2) exposure of the HMAC signing secret.

Fixes & mitigations

Don’t unserialize attacker‑controlled data. Use safer formats (JSON) or strictly validate and whitelist allowed classes before unserializing.

If you must use serialized objects, implement strict class whitelisting during unserialize (e.g., unserialize($data, ['allowed_classes' => [...]] )). Avoid magic methods doing dangerous work.

Keep secrets secret. Remove phpinfo from production and never expose app secrets via debug endpoints. Rotate secrets if leaked.

Defense in depth: limit what magic methods can do; avoid calls to system/exec from deserialization flows; run app with least privilege.

Harden cookie handling: consider signing and encrypting with rotating keys and strict scopes, but note: signing alone doesn’t protect you if secret leaks. Don’t rely on secrets being public‑safe.
