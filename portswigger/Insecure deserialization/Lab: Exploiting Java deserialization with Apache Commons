Java deserialization RCE via session cookie (CommonsCollections / ysoserial)

Lab Difficulty: Apprentice
Vulnerability: Unsafe Java deserialization → Remote Code Execution (RCE) via session cookie

Summary

The app stores your session as a serialized Java object inside a cookie. If you can swap that serialized blob for one that runs code when deserialized, the server will execute your command. This lab has Apache Commons Collections on the classpath, so a ysoserial CommonsCollections gadget works — generate a serialized payload that runs rm /home/carlos/morale.txt, Base64 it, URL‑encode it into the session cookie, send the request, and boom: lab solved.

Steps Taken (what I did and why)

Logged in as the provided user (wiener:peter) and opened DevTools → Application → Cookies to inspect the session cookie. It looked like a long Base64-ish string (A–Z a–z 0–9 + / =), so likely a Base64‑encoded Java serialized object.

Captured a normal request in Burp and sent it to Repeater so I could edit the cookie and resend requests easily. Nothing weird at first glance.

Prepared ysoserial on my attack machine to build a CommonsCollections gadget that executes the command the lab expects:

For Java ≤15:

java -jar ysoserial-all.jar CommonsCollections4 'rm /home/carlos/morale.txt' | base64


For Java 16+ (if your local Java complains and you need reflective opens):

java -jar ysoserial-all.jar \
  --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.trax=ALL-UNNAMED \
  --add-opens=java.xml/com.sun.org.apache.xalan.internal.xsltc.runtime=ALL-UNNAMED \
  --add-opens=java.base/java.net=ALL-UNNAMED \
  --add-opens=java.base/java.util=ALL-UNNAMED \
  CommonsCollections4 'rm /home/carlos/morale.txt' | base64


That printed a Base64 string (the serialized payload).

URL‑encoded the Base64 output (cookies can’t carry raw +, /, = reliably). In Burp: highlight cookie value → Encoder → URL encode.

Replaced the original serialized blob portion of the session cookie in the Repeater request with my URL‑encoded Base64 payload (careful to replace exactly the blob part, not other cookie bits).

Sent the modified request. If the server deserializes the cookie and the gadget matches the classpath/JRE, the injected payload runs and the lab detects the rm /home/carlos/morale.txt action — solved.

Root Cause

The server blindly deserializes user-controlled data from the cookie. Java deserialization can invoke arbitrary behavior during object reconstruction (and many common libraries contain “gadgets” that lead to Runtime.exec or similar). If an attacker can craft an object graph that triggers those gadgets, they get RCE. Encoding (Base64) doesn’t change the danger — it’s just a transport encoding.

Fixes and Mitigation

Stop deserializing untrusted data. Don’t accept Java serialized objects from clients. Use safer formats (JSON) or explicitly validated structures.

Sign and/or encrypt session blobs (and verify signatures) — but note: signing alone isn’t enough if the server still deserializes untrusted content after verifying. Prefer not to deserialize arbitrary objects at all.

Use a deserialization allowlist (only allow explicitly safe classes) or libraries that enforce it.

Remove unnecessary libraries from the classpath (e.g., Commons Collections) or upgrade to patched safe versions — reduces available gadget surface.

Apply principle of least privilege for the process — it shouldn’t have file-system power to delete arbitrary files.
